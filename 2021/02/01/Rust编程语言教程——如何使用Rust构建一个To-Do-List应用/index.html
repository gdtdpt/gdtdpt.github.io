<!DOCTYPE html>
<html lang="">
    <!-- title -->




<!-- keywords -->




<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="Richard Wong">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Richard Wong">
    
    <meta name="keywords" content="Richard,Richard Wong,Blog">
    
    <meta name="description" content="">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Rust编程语言教程——如何使用Rust构建一个To-Do List应用 · Richard&#39;s Blog</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href="/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="stylesheet" href="/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href="/assets/favicon.ico">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js" as="script">
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin="">
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin="">
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/">Richard&#39;s Blog</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">Rust编程语言教程——如何使用Rust构建一个To-Do List应用</a>
            </div>
    </div>
    
    <a class="home-link" href="/">Richard's Blog</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            Rust编程语言教程——如何使用Rust构建一个To-Do List应用
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class="post-intro-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="rust">rust</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags="serde">serde</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">6.5k</span>阅读时长: <span class="post-count reading-time">24 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2021/02/01</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <blockquote>
<p>原文链接<a href="https://www.freecodecamp.org/news/how-to-build-a-to-do-app-with-rust/" target="_blank" rel="noopener">Rust Programming Language Tutorial – How to Build a To-Do List App</a></p>
</blockquote>
<font size="6">自从Rust语言在2015的第一次开源，就获得了来自开源社区的大量关注。并且从2016年后，每一年都会被<a href="https://insights.stackoverflow.com/survey/2020#technology-most-loved-dreaded-and-wanted-languages" target="_blank" rel="noopener">StackOverflow</a>上的程序员票选为最喜爱的编程语言。</font>

<p>Rust由Mozilla开发并设计成一款系统编程语言(像C或C++)。它没有垃圾回收器，所以性能非常好。同时Rust设计得让Rust看起来和使用起来非常的”高级语言”。</p>
<p>Rust的学习曲线被认为有些陡峭。我不是一个精通Rust的人，但是在这个教程中我将尝试教给你一些概念和实际的方法，帮助你深入理解。</p>
<a id="more"></a>
<h1 id="我们将在这个实战教程中做什么"><a href="#我们将在这个实战教程中做什么" class="headerlink" title="我们将在这个实战教程中做什么"></a>我们将在这个实战教程中做什么</h1><p>我决定跟随传统的JavaScript应用做一个to-do应用做为我们的第一个项目。我们将用到命令行，所以必须了解一些命令行的基本操作。你当然也需要知道一些普遍的编程语言基础知识。</p>
<p>这个应用将运行在命令行中。我们将把待办项目和一个表示状态的布尔值存放在集合里。</p>
<h1 id="项目将包含什么"><a href="#项目将包含什么" class="headerlink" title="项目将包含什么"></a>项目将包含什么</h1><ul>
<li>Rust中的错误处理</li>
<li>可选类型和空</li>
<li>结构体和结构体的impl</li>
<li>终端的I/O</li>
<li>文件系统的使用</li>
<li>Rust中所有权和借取</li>
<li>Match模式</li>
<li>迭代器和闭包</li>
<li>使用外部库</li>
</ul>
<h1 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h1><p>在开始之前有一些建议给从事JavaScript的程序员：</p>
<ul>
<li>Rust是一个强类型的编程语言。这代表当编译器无法推断出变量的类型时，我们就必须标明此变量的类型。</li>
<li>而且不同于JavaScript，这里没有<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Automatic_semicolon_insertion" target="_blank" rel="noopener">AFI</a>。这代表我们必须写分号(;)，除非这条语句在一个方法中的最后一行。当一条语句在方法的最后一行并且结尾没有分号时代表此方法的返回值。</li>
</ul>
<p>事不宜迟，我们开始吧。</p>
<h1 id="Rust项目是如何开始的"><a href="#Rust项目是如何开始的" class="headerlink" title="Rust项目是如何开始的"></a>Rust项目是如何开始的</h1><p>开始的第一步当然是在你的电脑上下载并安装Rust。此步骤你可以跟随Rust的官方网站中的<a href="https://www.rust-lang.org/learn/get-started" target="_blank" rel="noopener">开始指引</a>完成。</p>
<p>在那里你也可以找到一些很好的方式将Rust整合进你喜欢的编辑器中。</p>
<p>有一个跟Rust编译器一起安装的工具叫<a href="https://doc.rust-lang.org/cargo/index.html" target="_blank" rel="noopener">Cargo</a>.Cargo是Rust的包管理工具，就像JavaScript程序员常用的npm或yarn一样。</p>
<p>创建工程的步骤很简单，只要去到你希望创建的工程目录下简单的运行<code>cargo new &lt;项目名&gt;</code>。在这个项目里我决定把项目命名为”todo-cli”，所以我需要运行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cargo new todo-cli</span></span><br></pre></td></tr></table></figure></p>
<p>现在进入刚刚创建的项目目录下，你会看到两个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tree .</span><br><span class="line">.</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line"> └── main.rs</span><br></pre></td></tr></table></figure></p>
<p>我们的教程只需要编写<code>src/main.rs</code>文件，所以直接打开它。</p>
<p>像很多其他语言一样，Rust也有一个main方法。<code>fn</code>是用来定义一个函数的，<code>println!</code>中的<code>!</code>表示这是一个<a href="https://doc.rust-lang.org/book/ch19-06-macros.html" target="_blank" rel="noopener">宏</a>。正如你所想的一样，现在这个刚生成的程序是一个Rust版的”hello world!”。</p>
<p>构建和执行只需要简单的运行<code>cargo run</code>命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cargo run</span></span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure>
<h1 id="如何读取参数"><a href="#如何读取参数" class="headerlink" title="如何读取参数"></a>如何读取参数</h1><p>我们的目标是让我们的命令接收两个参数：第一个是操作指令，第二个是待办事项。</p>
<p>我们从读取用户输入的参数并打印在控制台开始。</p>
<p>用以下的内容替换main函数中的内容：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> action = std::env::args().nth(<span class="number">1</span>).expect(<span class="string">"Please specify an action"</span>);</span><br><span class="line"><span class="keyword">let</span> item = std::env::args().nth(<span class="number">2</span>).expect(<span class="string">"Please specify an item"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;, &#123;:?&#125;"</span>, action, item);</span><br></pre></td></tr></table></figure>
<p>让我们来消化一下这些内容。</p>
<ul>
<li><code>let</code><a href="https://doc.rust-lang.org/std/keyword.let.html" target="_blank" rel="noopener">[doc]</a>为变量绑定数据。</li>
<li><code>std::env::args()</code><a href="https://doc.rust-lang.org/std/env/fn.args.html" target="_blank" rel="noopener">[doc]</a>是从基础包的<em>env</em>模块带来方法，此方法返回程序开始执行时所代的参数。由于它是一个迭代器，我们能使用<code>nth()</code>方法通过下标访问它储存的数据。下标为0的参数是程序本身，所以我们从第1个参数开始读取。</li>
<li><code>expect()</code><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.expect" target="_blank" rel="noopener">[doc]</a>是一个为了<code>Option</code>枚举而定义的一个方法，当值存在时它会返回值，当值不存在时它将会立刻停止程序(Rust概念中的Panic)，并返回预设的信息。</li>
</ul>
<p>因为我们可以不填写参数直接运行程序，Rust需要我们去检查是否确实提供了参数，所以返回给我们可选类型(Option type)：有参数，或者没有。</p>
<p>作为程序员，我们有责任确保在每种情况下都采取适当的措施。</p>
<p>当没有参数时，我们暂且立刻退出程序。</p>
<p>来让我们运行程序并带上两个参数。将需要带上的参数写在<code>--</code>后面。比如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cargo run -- hello world!</span></span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.01s</span><br><span class="line">     Running `target/debug/todo_cli hello 'world'\!''`</span><br><span class="line">"hello", "world!"</span><br></pre></td></tr></table></figure></p>
<h1 id="如何使用自定义的数据类型添加和保存数据"><a href="#如何使用自定义的数据类型添加和保存数据" class="headerlink" title="如何使用自定义的数据类型添加和保存数据"></a>如何使用自定义的数据类型添加和保存数据</h1><p>让我们花一点时间想一下我们的程序想做到的目标。我们想读取用户传递的参数，然后更新我们的列表，并保存在某个地方以备使用。</p>
<p>为了实现这些功能，我们将实现我们自己的数据类型，并为类型定义符合业务逻辑的方法。</p>
<p>我们将使用Rust的<a href="https://doc.rust-lang.org/std/keyword.struct.html" target="_blank" rel="noopener">结构体(struct)]</a>，它可以让我们清晰的实现以上的想法。它也可以避免我们把所有的代码都写在main函数内。</p>
<h2 id="如果定义我们的结构体"><a href="#如果定义我们的结构体" class="headerlink" title="如果定义我们的结构体"></a>如果定义我们的结构体</h2><p>由于我们在之后步骤中要经常操作HashMap，所以我们可以将它引入我们当前文件的作用域中，之后可以少打一些字。</p>
<p>在我们的文件顶部添加以下内容：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap</span><br></pre></td></tr></table></figure>
<p>这样做可以让我们直接使用<code>HashMap</code>，不需要每次都写完整的路径。</p>
<p>在main函数下方添加以下代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Todo</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用rust内置的HashMap存储键值对</span></span><br><span class="line">    map: HashMap&lt;<span class="built_in">String</span>, <span class="built_in">bool</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就定义了我们的Todo类型：一个结构体，结构体中有一个叫”map”的属性。</p>
<p>这个属性是一个<a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html" target="_blank" rel="noopener">HashMap</a>。你可以把它想像成JavaScript中的object对象，不过rust要求我们必须声明它的key和value的类型。</p>
<ul>
<li><code>HashMap&lt;String, bool&gt;</code>表示我们的键(key)是String类型，值(value)是布尔类型(bool)，值会被用于表示状态。</li>
</ul>
<h2 id="如果在我们的结构体中添加方法"><a href="#如果在我们的结构体中添加方法" class="headerlink" title="如果在我们的结构体中添加方法"></a>如果在我们的结构体中添加方法</h2><p>方法就像普通的函数一样，通过<code>fn</code>关键字定义方法、参数和返回值。</p>
<p>然而与普通函数有所区别的地方是方法定义在结构体的上下文中，并且他们的第一个参数总是<code>self</code>对象。</p>
<p>我们在下面的代码中会向刚创建的结构体中添加一个<em>impl</em>(implementation)块。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Todo &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">insert</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, key: <span class="built_in">String</span>) &#123;</span><br><span class="line">        <span class="comment">// 向我们的map中添加一个新的待办事项。</span></span><br><span class="line">        <span class="comment">// 我们传一个true作为value</span></span><br><span class="line">        <span class="keyword">self</span>.map.insert(key, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数非常简单：它简单获取一个当前结构体的引用和一个键(key)，使用HashMap自带的<a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.insert" target="_blank" rel="noopener">insert</a>方法添加到我们的map中。</p>
<p>这里有两个非常重要的信息：</p>
<ul>
<li>mut<a href="https://doc.rust-lang.org/std/keyword.mut.html" target="_blank" rel="noopener">说明</a>可以使一个变量可变。<br>在Rust中所有的变量默认是不可变的。如果你希望更新变量的值，你需要使用<code>mut</code>关键字使变量可变。由于我们的函数需要向我们的map中添加新的数据，所以我们需要声明这个变量是可变的。</li>
<li>&amp;<a href="https://doc.rust-lang.org/std/primitive.reference.html" target="_blank" rel="noopener">说明</a>表示这是一个引用。<br>你可以将此变量想象为一个指针，指向数据所在的内存地址，而不是数据本身。</li>
</ul>
<p>在Rust的概念中这相当于一个<strong>借用</strong>，意思是这个函数并不实际拥有变量的值，只是指向值所在的存储地址。</p>
<h1 id="简单概述一下Rust的所有权系统"><a href="#简单概述一下Rust的所有权系统" class="headerlink" title="简单概述一下Rust的所有权系统"></a>简单概述一下Rust的所有权系统</h1><p>由于先前的提示中有关于借用与引用的内容，所以现在可以简单的说一下所有权的概念。</p>
<p>所有权是Rust最独特的功能。它令Rust在写程序的时候不需要人为的申请内存空间(不像C/C++那样)，但同时运行的时候也不需要垃圾回收器(类似JavaScript或Python)不断地监控程序的内存并把不使用的内存释放。</p>
<p>所有权系统有三条规则：</p>
<ul>
<li>每一个在Rust中的值都有一个变量：它自己。</li>
<li>每一个值只能在同一时间内存在唯一一个所有者。</li>
<li>当值的所有者离开了它所在的区域，值将会被废弃。</li>
</ul>
<p>Rust会在编译的时候检查这些规则，所以你必须清楚你需要的值的内存在什么时候被释放。</p>
<p>想一下这个例子：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line"> <span class="comment">// String的所有者是x</span></span><br><span class="line"> <span class="keyword">let</span> x = <span class="built_in">String</span>::from(<span class="string">"Hello"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 我们将值移动至函数中</span></span><br><span class="line"> <span class="comment">// 现在doSomething是x的所有者。</span></span><br><span class="line"> <span class="comment">// 当它离开doSomething的区域时</span></span><br><span class="line"> <span class="comment">// Rust将释放与x相关的内存。</span></span><br><span class="line"> doSomething(x);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果我们尝试再次使用x时，编译器会抛出一个错误</span></span><br><span class="line"> <span class="comment">// 由于我们已经把它移动到"doSomething"里面了</span></span><br><span class="line"> <span class="comment">// 所以我们不能使用它，因为我们没有它的所有权</span></span><br><span class="line"> <span class="comment">// 因此x的值将被丢弃。</span></span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个概念被认为是在学习Rust的过程中最难掌握的，可能是因为这是一个与其他编程语言不同的全新概念。</p>
<p>您可以从Rust的官方文档中阅读有关<a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html" target="_blank" rel="noopener">所有权</a>的更深入的说明。</p>
<p>我们不会深入研究所有权制度的来龙去脉。现在，请记住我上面提到的规则。尝试在每个步骤中考虑是否需要”拥有”这些值然后删除它们，或者是否需要引用它以便可以保留它。</p>
<p>例如，在上面的insert方法中，我们不想拥有<code>map</code>对象，因为我们仍然需要它来存储数据。只有这样，我们才能在方法的最后正确的释放内存。</p>
<h2 id="如何将map中的数据存到硬盘上"><a href="#如何将map中的数据存到硬盘上" class="headerlink" title="如何将map中的数据存到硬盘上"></a>如何将map中的数据存到硬盘上</h2><p>由于这是一个演示应用程序，因此我们将采用最简单的长期存储解决方案：将map写入到文件中。</p>
<p>让我们在<code>impl</code>块中创建一个新方法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Todo &#123;</span><br><span class="line">    <span class="comment">// [其他的代码]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">save</span></span>(<span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;(), std::io::Error&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> content = <span class="built_in">String</span>::new();</span><br><span class="line">        <span class="keyword">for</span> (k, v) <span class="keyword">in</span> <span class="keyword">self</span>.map &#123;</span><br><span class="line">            <span class="keyword">let</span> record = <span class="built_in">format!</span>(<span class="string">"&#123;&#125;\t&#123;&#125;\n"</span>, k, v);</span><br><span class="line">            content.push_str(&amp;record)</span><br><span class="line">        &#125;</span><br><span class="line">        std::fs::write(<span class="string">"db.txt"</span>, content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-&gt;</code>标记指定从函数返回的类型。我们返回一个<code>Result</code>类型。</li>
<li>我们遍历map，格式化每个字符串，用制表符(\n)分隔键和值，并在最后换到新的一行。</li>
<li>我们将已经格式化好的字符串推入content变量中。</li>
<li>我们将<code>content</code>写入名为<code>db.txt</code>的文件内。</li>
</ul>
<p>重要的是要注意，<code>save</code>拥有自己的<em>所有权</em>。<br>这是一个故意为之的设计，这样编译器会阻止我们在调用save之后尝试更新map(因为self的内存已被释放)。</p>
<p>这是个人决定”强制”把save方法为最后使用的方法。这是一个完美的例子，展示了如何使用Rust的内存管理来创建更严格的代码。违反此规则的代码将无法通过编译(这有助于防止开发过程中的人为错误)。</p>
<h2 id="如何在main函数中使用结构体"><a href="#如何在main函数中使用结构体" class="headerlink" title="如何在main函数中使用结构体"></a>如何在main函数中使用结构体</h2><p>现在我们的结构体有了两个方法，我们可以开始使用它们了。从main函数读取参数开始。现在如果提供的操作是”add”，我们会将待办事项插入文件中并存储以供以后使用。</p>
<p>将这些行添加到两个参数绑定下面：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// ...[参数绑定代码]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> todo = Todo &#123;</span><br><span class="line">        map: HashMap::new(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> action == <span class="string">"add"</span> &#123;</span><br><span class="line">        todo.insert(item);</span><br><span class="line">        <span class="keyword">match</span> todo.save() &#123;</span><br><span class="line">            <span class="literal">Ok</span>(_) =&gt; <span class="built_in">println!</span>(<span class="string">"todo saved"</span>),</span><br><span class="line">            <span class="literal">Err</span>(why) =&gt; <span class="built_in">println!</span>(<span class="string">"An error occurred: &#123;&#125;"</span>, why),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们看看我们在这里做什么：</p>
<ul>
<li><code>let mut todo = Todo</code>让我们实例化一个结构，将其绑定为可变的。</li>
<li>我们通过<code>.</code>符号调用<code>TODO insert</code>方法。</li>
<li>我们将<a href="https://doc.rust-lang.org/std/keyword.match.html" target="_blank" rel="noopener">匹配</a>save方法返回的结果，并在每种情况下都会在屏幕上打印一条消息。</li>
</ul>
<p>让我们测试一下。导航到您的终端并输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cargo run -- add <span class="string">"code rust"</span></span></span><br><span class="line">todo saved</span><br></pre></td></tr></table></figure>
<p>让我们查看一下已保存的待办事项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat db.txt</span></span><br><span class="line">code rust true</span><br></pre></td></tr></table></figure>
<p>到目前为止，您可以<a href="https://gist.github.com/Marmiz/b67e98c2fc7be3561d124294cf3cb6ac" target="_blank" rel="noopener">在这</a>找到完整的代码片段。</p>
<h1 id="如何读取文件"><a href="#如何读取文件" class="headerlink" title="如何读取文件"></a>如何读取文件</h1><p>现在，我们的程序有一个根本性的缺陷：每次”add”时，我们都会覆盖map而不是对其进行更新。这是因为我们每次运行程序时都会创建一个新的空map。让我们修复这个缺陷。</p>
<h2 id="在TODO中添加新的功能"><a href="#在TODO中添加新的功能" class="headerlink" title="在TODO中添加新的功能"></a>在TODO中添加新的功能</h2><p>我们将为Todo结构体实现一个新功能。调用后，将读取文件的内容，并将已存储的值返还给我们的Todo。请注意，这不是方法(指实例方法)，因为它没有将<code>self</code>作为第一个参数。</p>
<p>我们将其称为<code>new</code>，这只是Rust的约定(请参阅之前使用的HashMap::new())。</p>
<p>让我们在impl块中添加以下代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Todo &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="built_in">Result</span>&lt;Todo, std::io::Error&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> f = std::fs::OpenOptions::new()</span><br><span class="line">            .write(<span class="literal">true</span>)</span><br><span class="line">            .create(<span class="literal">true</span>)</span><br><span class="line">            .read(<span class="literal">true</span>)</span><br><span class="line">            .open(<span class="string">"db.txt"</span>)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> content = <span class="built_in">String</span>::new();</span><br><span class="line">        f.read_to_string(&amp;<span class="keyword">mut</span> content)?;</span><br><span class="line">        <span class="keyword">let</span> map: HashMap&lt;<span class="built_in">String</span>, <span class="built_in">bool</span>&gt; = content</span><br><span class="line">            .lines()</span><br><span class="line">            .map(|line| line.splitn(<span class="number">2</span>, <span class="string">'\t'</span>).collect::&lt;<span class="built_in">Vec</span>&lt;&amp;<span class="built_in">str</span>&gt;&gt;())</span><br><span class="line">            .map(|v| (v[<span class="number">0</span>], v[<span class="number">1</span>]))</span><br><span class="line">            .map(|(k, v)| (<span class="built_in">String</span>::from(k), <span class="built_in">bool</span>::from_str(v).unwrap()))</span><br><span class="line">            .collect();</span><br><span class="line">        <span class="literal">Ok</span>(Todo &#123; map &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...剩下的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果感到有点压力的话，请不要担心。我们为此使用了一种更具功能性的编程风格，主要是展示并介绍Rust支持许多其他语言中的范式，比如迭代器，闭包和lambda函数。</p>
<p>让我们看看这里发生了什么：</p>
<ul>
<li>我们正在定义一个<code>new</code>函数，它将返回一个<code>Todo</code>结构体或<code>io:Error</code>。</li>
<li>我们通过定义各种<code>OpenOptions</code>配置如何打开”db.txt”文件。最值得注意的是<code>create(true)</code>标记，如果文件不存在，它将创建该文件。</li>
<li><code>f.read_to_string(&amp;mut content)?</code>读取所有文件中的字节并放入<code>content</code>字符串中。<br>注意：记得将<code>use std::io::Read;</code>添加到文件顶端，这样才能使用<code>read_to_string</code>方法。</li>
<li>我们需要将文件的String类型转换为HashMap。为此，我们将map变量与此行绑定在一起：<code>let map: HashMap&lt;String, bool&gt;</code>。这是编译器无法做类型推断的情况之一，因此我们需要自己声明类型。</li>
<li>lines<a href="https://doc.rust-lang.org/std/primitive.str.html#method.lines" target="_blank" rel="noopener">文档</a>方法创建一个迭代器迭代每一行字符串，意思是现在我们将迭代文件中的每一个元素，因此我们将每个元素的末尾都加上<code>/n</code>.</li>
<li>map<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map" target="_blank" rel="noopener">文档</a>方法接收一个闭包，并且在迭代器迭代到每一个元素时调用此闭包。</li>
<li><code>line.splitn(2, &#39;\t&#39;)</code><a href="https://doc.rust-lang.org/std/primitive.str.html#method.splitn" target="_blank" rel="noopener">文档</a>此代码将根据tab制表符分割每行的字符。</li>
<li><code>collect::&lt;Vec&lt;&amp;str&gt;&gt;()</code><a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.collect" target="_blank" rel="noopener">文档</a>如文档中所述，它是标准库中功能最强大的方法之一：它将迭代器转换为相关的集合。<br>在这里我们使用<code>::Vec&lt;&amp;str&gt;</code>告诉map方法转换我们已分割的字符串的借用切片到一个Vector中。这是在告诉编译器我们在操作结束后希望获得怎样的集合。</li>
<li>然后我们使用<code>.map(|v| (v[0], v[1]))</code>将其转换为元组以方便使用。</li>
<li>然后我们使用以下方法将元组的两个元素转换为String和boolean<code>.map(|(k, v)| (String::from(k), bool::from_str(v).unwrap()))</code>。<br>注意：记得在文件头部添加<code>use std::str::FromStr;</code>，这样才能使用<code>from_str</code>方法。</li>
<li>我们最终将它们收集到我们的HashMap中。这次我们不需要声明类型，因为Rust从绑定声明中推断出它。</li>
<li>最后，如果我们未遇到任何错误，我们将使用<code>Ok(Todo { map })</code>把结构体返回给调用者。<br>请注意，就像在JavaScript中一样，如果键和变量在结构内具有相同的名称，则可以使用较短的表示方法。</li>
</ul>
<h2 id="另一种方式"><a href="#另一种方式" class="headerlink" title="另一种方式"></a>另一种方式</h2><p>尽管通常认为map更加惯用，但以上内容也可以使用<code>for</code>循环来实现。随意使用最喜欢的一种。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="built_in">Result</span>&lt;Todo, std::io::Error&gt; &#123;</span><br><span class="line">    <span class="comment">// 打开db文件</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> f = std::fs::OpenOptions::new()</span><br><span class="line">        .write(<span class="literal">true</span>)</span><br><span class="line">        .create(<span class="literal">true</span>)</span><br><span class="line">        .read(<span class="literal">true</span>)</span><br><span class="line">        .open(<span class="string">"db.txt"</span>)?;</span><br><span class="line">    <span class="comment">// 将内容读到字符串变量中</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> content = <span class="built_in">String</span>::new();</span><br><span class="line">    f.read_to_string(&amp;<span class="keyword">mut</span> content)?;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明一个空的HashMap</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环文件的每一行</span></span><br><span class="line">    <span class="keyword">for</span> entries <span class="keyword">in</span> content.lines() &#123;</span><br><span class="line">        <span class="comment">// 分割和绑定值</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> values = entries.split(<span class="string">'\t'</span>);</span><br><span class="line">        <span class="keyword">let</span> key = values.next().expect(<span class="string">"No Key"</span>);</span><br><span class="line">        <span class="keyword">let</span> val = values.next().expect(<span class="string">"No Value"</span>);</span><br><span class="line">        <span class="comment">// 把分割出来的值添加入HashMap</span></span><br><span class="line">        map.insert(<span class="built_in">String</span>::from(key), <span class="built_in">bool</span>::from_str(val).unwrap());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回Ok</span></span><br><span class="line">    <span class="literal">Ok</span>(Todo &#123; map &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码在功能上等效于以前使用的“功能更强”的方法。</p>
<h2 id="如何使用new方法"><a href="#如何使用new方法" class="headerlink" title="如何使用new方法"></a>如何使用new方法</h2><p>在main内部，只需使用以下代码更新绑定todo变量的方式：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> todo = Todo::new().expect(<span class="string">"Initialisation of db failed"</span>);</span><br></pre></td></tr></table></figure></p>
<p>现在，如果我们回到终端并运行一堆”add”命令，我们应该看到我们的数据库正确更新：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cargo run -- add <span class="string">"make coffee"</span></span></span><br><span class="line">todo saved</span><br><span class="line"><span class="meta">$</span><span class="bash"> cargo run -- add <span class="string">"make pancakes"</span></span></span><br><span class="line">todo saved</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat db.txt</span></span><br><span class="line">make coffee     true</span><br><span class="line">make pancakes   true</span><br></pre></td></tr></table></figure>
<p>您可以<a href="https://gist.github.com/Marmiz/b659c7835054d25513106e3804c4539f" target="_blank" rel="noopener">在这</a>找到所有现阶段的代码片段。</p>
<h1 id="如何更新集合中的值"><a href="#如何更新集合中的值" class="headerlink" title="如何更新集合中的值"></a>如何更新集合中的值</h1><p>就像在所有TODO应用程序中一样，我们希望不仅能够添加待办项目，而且能够对其进行切换并将其标记为已完成。</p>
<h2 id="如果添加完成的方法"><a href="#如果添加完成的方法" class="headerlink" title="如果添加完成的方法"></a>如果添加完成的方法</h2><p>为了做到这个功能，我们先向我们的结构体中添加一个”complete”方法。在方法中，我们获取一个键(key)的引用，更新它的值，或者在键不存在的时候返回<code>None</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Todo &#123;</span><br><span class="line"><span class="comment">// [TODO剩下的方法]</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">complete</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, key: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">Option</span>&lt;()&gt; &#123;</span><br><span class="line">      <span class="keyword">match</span> <span class="keyword">self</span>.map.get_mut(key) &#123;</span><br><span class="line">          <span class="literal">Some</span>(v) =&gt; <span class="literal">Some</span>(*v = <span class="literal">false</span>),</span><br><span class="line">          <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们看看这里发生了什么：</p>
<ul>
<li>我们定义了方法的返回值：一个空的<code>Option</code>。</li>
<li>整个方法会返回Match表达式的结果，一个空的<code>Some()</code>或者<code>None</code>。</li>
<li><code>self.map.get_mut</code><a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.get_mut" target="_blank" rel="noopener">文档</a>会返回给我们一个key所对应的可变的值引用，当key没有储存的值则返回<code>None</code>。</li>
<li>我们使用<code>*</code><a href="https://doc.rust-lang.org/book/appendix-02-operators.html" target="_blank" rel="noopener">文档</a>操作符解引用并设置成false。</li>
</ul>
<h2 id="如何使用complete方法"><a href="#如何使用complete方法" class="headerlink" title="如何使用complete方法"></a>如何使用complete方法</h2><p>我们可以像之前使用insert一样使用”complete”方法。</p>
<p>在<code>main</code>中，我们使用<code>else if</code>语句检查作为参数传递的操作是否是”complete”：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在main函数中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> action == <span class="string">"add"</span> &#123;</span><br><span class="line">    <span class="comment">// 添加action的片断</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> action == <span class="string">"complete"</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> todo.complete(&amp;item) &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">"'&#123;&#125;' is not present in the list"</span>, item),</span><br><span class="line">        <span class="literal">Some</span>(_) =&gt; <span class="keyword">match</span> todo.save() &#123;</span><br><span class="line">            <span class="literal">Ok</span>(_) =&gt; <span class="built_in">println!</span>(<span class="string">"todo saved"</span>),</span><br><span class="line">            <span class="literal">Err</span>(why) =&gt; <span class="built_in">println!</span>(<span class="string">"An error occurred: &#123;&#125;"</span>, why),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是时候分析一下我们在这里做什么了：</p>
<ul>
<li>我们使用<code>todo.complete(&amp;item)</code>方法匹配了Option的返回值。</li>
<li>如果匹配到<code>None</code>我们会向用户打印警告，以获得更好的体验。<br>我们使用<code>&amp;item</code>传递item的引用给”todo.complete”函数，因此item的值的仍然被当前方法所拥有。这代表我们可以在后面使用<code>println!</code>宏。<br>如果我们不这么做，item的值将会被”complete”拥有，并且在”complete”方法结束时被丢弃。</li>
<li>如果我们匹配到返回值为<code>Some</code>，我们调用<code>todo.save</code>持久化我们的数据至文件中。</li>
</ul>
<h1 id="尝试运行程序"><a href="#尝试运行程序" class="headerlink" title="尝试运行程序"></a>尝试运行程序</h1><p>现在该尝试在终端机中本地开发的应用程序了。让我们首先删除db文件以重新开始。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm db.txt</span></span><br></pre></td></tr></table></figure>
<p>然后添加和修改一些待办事项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cargo run -- add <span class="string">"make coffee"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cargo run -- add <span class="string">"code rust"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cargo run -- complete <span class="string">"make coffee"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat db.txt</span></span><br><span class="line">make coffee     false</span><br><span class="line">code rust       true</span><br></pre></td></tr></table></figure>
<p>这意味着在这些命令的末尾，我们有一个完成的操作(“make coffee”)和一个尚待执行的操作：”code rust”。</p>
<p>假设我们要再次煮咖啡：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cargo run -- add <span class="string">"make coffee</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat db.txt</span></span><br><span class="line">make coffee     true</span><br><span class="line">code rust       true</span><br></pre></td></tr></table></figure>
<h1 id="奖励：如何使用Serde储存JSON数据"><a href="#奖励：如何使用Serde储存JSON数据" class="headerlink" title="奖励：如何使用Serde储存JSON数据"></a>奖励：如何使用Serde储存JSON数据</h1><p>这是一个可运行的很小的程序。但是，让我们稍微改变一下。在JavaScript世界里我们更喜欢使用JSON文件而不是纯文本文件。</p>
<p>我们将借此机会来看看如何安装和使用Rust开源社区的软件包，来自<a href="https://crates.io/" target="_blank" rel="noopener">crates.io</a>。</p>
<h2 id="如果安装Serde"><a href="#如果安装Serde" class="headerlink" title="如果安装Serde"></a>如果安装Serde</h2><p>为了安装新的包到我们的项目中，打开<code>cargo.toml</code>文件。在文件底部你可以看到<code>[dependencies]</code>字段：简单的把如下信息添加到文件中：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">serde_json</span> = <span class="string">"1.0.60"</span></span><br></pre></td></tr></table></figure>
<p>这样就可以了，下一次编译时cargo会帮我们下载需要的包并编译代码。</p>
<h2 id="如何升级Todo-new方法"><a href="#如何升级Todo-new方法" class="headerlink" title="如何升级Todo::new方法"></a>如何升级Todo::new方法</h2><p>我们要使用Serde的第一个地方是在读取db文件时。现在，我们要读取一个JSON文件，而不是读取”.txt”。</p>
<p>升级在<code>impl</code>代码块中的<code>new</code>方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Todo的impl块</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="built_in">Result</span>&lt;Todo, std::io::Error&gt; &#123;</span><br><span class="line">    <span class="comment">// 打开db.json</span></span><br><span class="line">    <span class="keyword">let</span> f = std::fs::OpenOptions::new()</span><br><span class="line">        .write(<span class="literal">true</span>)</span><br><span class="line">        .create(<span class="literal">true</span>)</span><br><span class="line">        .read(<span class="literal">true</span>)</span><br><span class="line">        .open(<span class="string">"db.json"</span>)?;</span><br><span class="line">    <span class="comment">// 将json序列化成HashMap</span></span><br><span class="line">    <span class="keyword">match</span> serde_json::from_reader(f) &#123;</span><br><span class="line">        <span class="literal">Ok</span>(map) =&gt; <span class="literal">Ok</span>(Todo &#123; map &#125;),</span><br><span class="line">        <span class="literal">Err</span>(e) <span class="keyword">if</span> e.is_eof() =&gt; <span class="literal">Ok</span>(Todo &#123;</span><br><span class="line">            map: HashMap::new(),</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="literal">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">"An error occurred: &#123;&#125;"</span>, e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显着的变化是：</p>
<ul>
<li>不再需要<code>mut f</code>绑定文件option对象，我们不需要在此之前人为申请储存内容的字符串内存。Serde会为我们处理好它。</li>
<li>我们升级文件后缀为<code>db.json</code>。</li>
<li><code>serde_json::from_reader</code><a href="https://docs.serde.rs/serde_json/fn.from_reader.html" target="_blank" rel="noopener">文档</a>将为我们反序列化文件。它会干扰map的返回类型，并将尝试将JSON转换为兼容的HashMap。如果一切顺利将会像之前一样返回<code>Todo</code>结构体。</li>
<li><code>Err(e) if e.is_eof()</code>是一个<a href="https://doc.rust-lang.org/reference/expressions/match-expr.html#match-guards" target="_blank" rel="noopener">匹配断言</a>，它可以使我们完善Match语句的行为。<br>如果Serde返回一个过早EOF(end of file)错误，这代表那个文件是完全的空白(例如在第一次运行时，或者如果我们删除了文件)。在那种情况下，我们从错误中恢复并返回一个空的HashMap。</li>
<li>对于所有其他错误，立即退出程序。</li>
</ul>
<h2 id="如何升级Todo-save"><a href="#如何升级Todo-save" class="headerlink" title="如何升级Todo.save"></a>如何升级Todo.save</h2><p>我们要使用Serde的另一个地方是将map另存为JSON。为此，将impl块中的<code>save</code>方法更新为：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Todo的impl块里</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">save</span></span>(<span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">Box</span>&lt;dyn std::error::Error&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 打开 db.json</span></span><br><span class="line">    <span class="keyword">let</span> f = std::fs::OpenOptions::new()</span><br><span class="line">        .write(<span class="literal">true</span>)</span><br><span class="line">        .create(<span class="literal">true</span>)</span><br><span class="line">        .open(<span class="string">"db.json"</span>)?;</span><br><span class="line">    <span class="comment">// 使用serde写入文件</span></span><br><span class="line">    serde_json::to_writer_pretty(f, &amp;<span class="keyword">self</span>.map)?;</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和以前一样，让我们​​看看我们在这里所做的更改：</p>
<ul>
<li><code>Box&lt;dyn std::error::Error&gt;</code>。这次我们返回<a href="https://doc.rust-lang.org/std/boxed/index.html" target="_blank" rel="noopener">Box</a>包含一个Rust中通用错误实现。<br>简而言之，盒子是指向内存中分配的指针。<br>由于打开文件时可能会返回文件系统错误，而转换文件时可能会返回Serde错误，所以我们实际上并不知道函数会返回这两个错误中的哪一个。<br>因此，我们返回一个指向可能错误的指针，而不是错误本身，以便调用者处理它们。</li>
<li>我们当然已经将文件名更新为<code>db.json</code>以匹配其他方法。</li>
<li>最后，我们让Serde承担繁重的工作，并将HashMap编写为JSON文件(标准格式)。</li>
<li>记得删除文件开关的<code>use std::io::Read;</code>和<code>use std::str::FromStr;</code>，我们不再需要它们了。</li>
</ul>
<p>这样就完成了。</p>
<p>现在，您可以运行程序并检查保存到文件中的输出。如果一切顺利，现在您应该将待办事项另存为JSON。</p>
<p>您可以在<a href="https://gist.github.com/Marmiz/541c3ccea832a27bfb60d4882450a4a8" target="_blank" rel="noopener">gist</a>中找到为此编写的完整代码。</p>
<h1 id="结束语，技巧和其他资源"><a href="#结束语，技巧和其他资源" class="headerlink" title="结束语，技巧和其他资源"></a>结束语，技巧和其他资源</h1><p>这是一段漫长的旅程，很荣幸您能与我同在。 我希望您能学到一些东西，并且对本入门书有所好奇。别忘了我们使用的是非常”低级”的语言，但是大多数人可能对代码的审查非常熟悉。</p>
<p>这就是我个人吸引Rust的原因–它使我能够编写既快速又具有内存效率的代码，而不必担心这种责任感：我知道编译器将在我身边，甚至让我有可能运行它之前停止我的动作。</p>
<p>在结束之前，我想与您分享一些其他技巧和资源，以帮助您在Rust的旅程中前进：</p>
<ul>
<li><a href="https://github.com/rust-lang/rustfmt" target="_blank" rel="noopener">Rust fmt</a>这是一个非常方便的工具，您可以按照一致的模式来设置代码格式。不再浪费时间配置您喜欢的linter插件。</li>
<li><code>cargo check</code><a href="https://doc.rust-lang.org/cargo/commands/cargo-check.html" target="_blank" rel="noopener">文档</a>会尝试不运行而编译代码：这在开发时非常有用，您只想在不实际运行的情况下检查代码的正确性。</li>
<li>Rust随附了集成的测试套件和生成文档的工具：<a href="https://doc.rust-lang.org/cargo/commands/cargo-test.html" target="_blank" rel="noopener">cargo test</a>和<a href="https://doc.rust-lang.org/cargo/commands/cargo-rustdoc.html" target="_blank" rel="noopener">cargo doc</a>。这次我们没有涉及它们，因为本教程看起来很密集。也许在将来。</li>
</ul>
<p>在我看来，要了解有关该语言的更多信息，最好的资源是：</p>
<ul>
<li>官方的<a href="https://www.rust-lang.org/" target="_blank" rel="noopener">Rust website</a>，收集所有信息的地方。</li>
<li>如果您喜欢通过聊天进行互动，Rust的<a href="https://discord.gg/rust-lang" target="_blank" rel="noopener">Discord</a>服务器有一个非常活跃和乐于助人的社区。</li>
<li>如果您喜欢读书，”<a href="https://doc.rust-lang.org/book/title-page.html" target="_blank" rel="noopener">The Rust programming language</a>“是您的正确选择。</li>
<li>如果您更喜欢视频类型，Ryan Levick的<a href="https://youtu.be/WnWGO-tLtLA" target="_blank" rel="noopener">Rust介绍</a>视频系列是一个了不起的资源。</li>
</ul>
<p>您可以在<a href="https://github.com/Marmiz/todo-cli" target="_blank" rel="noopener">GitHub</a>上的本文的源代码。</p>
<p>封面图开源于<a href="https://rustacean.net/" target="_blank" rel="noopener">https://rustacean.net/</a>。</p>
<p>感谢您的阅读和快乐编码！</p>

    </article>
    <!-- license  -->
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href="/2020/06/18/Mac删除深信服-sangfor-的EasyConnect/" title="Mac删除深信服(sangfor)的EasyConnect">
                    <div class="prevTitle">Mac删除深信服(sangfor)的EasyConnect</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:gdtdpt@foxmail.com" class="iconfont-archer email" title="email"></a>
            
        
    
        
            
                <a href="//github.com/gdtdpt" class="iconfont-archer github" target="_blank" title="github"></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#我们将在这个实战教程中做什么"><span class="toc-number">1.</span> <span class="toc-text">我们将在这个实战教程中做什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#项目将包含什么"><span class="toc-number">2.</span> <span class="toc-text">项目将包含什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#开始之前"><span class="toc-number">3.</span> <span class="toc-text">开始之前</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Rust项目是如何开始的"><span class="toc-number">4.</span> <span class="toc-text">Rust项目是如何开始的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#如何读取参数"><span class="toc-number">5.</span> <span class="toc-text">如何读取参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#如何使用自定义的数据类型添加和保存数据"><span class="toc-number">6.</span> <span class="toc-text">如何使用自定义的数据类型添加和保存数据</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#如果定义我们的结构体"><span class="toc-number">6.1.</span> <span class="toc-text">如果定义我们的结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如果在我们的结构体中添加方法"><span class="toc-number">6.2.</span> <span class="toc-text">如果在我们的结构体中添加方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#简单概述一下Rust的所有权系统"><span class="toc-number">7.</span> <span class="toc-text">简单概述一下Rust的所有权系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#如何将map中的数据存到硬盘上"><span class="toc-number">7.1.</span> <span class="toc-text">如何将map中的数据存到硬盘上</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何在main函数中使用结构体"><span class="toc-number">7.2.</span> <span class="toc-text">如何在main函数中使用结构体</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#如何读取文件"><span class="toc-number">8.</span> <span class="toc-text">如何读取文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#在TODO中添加新的功能"><span class="toc-number">8.1.</span> <span class="toc-text">在TODO中添加新的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#另一种方式"><span class="toc-number">8.2.</span> <span class="toc-text">另一种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何使用new方法"><span class="toc-number">8.3.</span> <span class="toc-text">如何使用new方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#如何更新集合中的值"><span class="toc-number">9.</span> <span class="toc-text">如何更新集合中的值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#如果添加完成的方法"><span class="toc-number">9.1.</span> <span class="toc-text">如果添加完成的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何使用complete方法"><span class="toc-number">9.2.</span> <span class="toc-text">如何使用complete方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#尝试运行程序"><span class="toc-number">10.</span> <span class="toc-text">尝试运行程序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#奖励：如何使用Serde储存JSON数据"><span class="toc-number">11.</span> <span class="toc-text">奖励：如何使用Serde储存JSON数据</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#如果安装Serde"><span class="toc-number">11.1.</span> <span class="toc-text">如果安装Serde</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何升级Todo-new方法"><span class="toc-number">11.2.</span> <span class="toc-text">如何升级Todo::new方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何升级Todo-save"><span class="toc-number">11.3.</span> <span class="toc-text">如何升级Todo.save</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结束语，技巧和其他资源"><span class="toc-number">12.</span> <span class="toc-text">结束语，技巧和其他资源</span></a></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 19
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2021 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/01</span><a class="archive-post-title" href="/2021/02/01/Rust编程语言教程——如何使用Rust构建一个To-Do-List应用/">Rust编程语言教程——如何使用Rust构建一个To-Do List应用</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/18</span><a class="archive-post-title" href="/2020/06/18/Mac删除深信服-sangfor-的EasyConnect/">Mac删除深信服(sangfor)的EasyConnect</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/09</span><a class="archive-post-title" href="/2020/05/09/Nginx配置一个端口同时处理多种协议/">Nginx配置一个端口同时处理多种协议</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/15</span><a class="archive-post-title" href="/2020/04/15/数据库中间件MyCat或dble在activiti-5-22中报invalid-stream-header-EFBFBDEF的问题处理记录/">数据库中间件MyCat或dble在activiti-5.22中报invalid stream header: EFBFBDEF的问题处理记录</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/21</span><a class="archive-post-title" href="/2019/08/21/Golang的交叉编译/">Golang的交叉编译</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/20</span><a class="archive-post-title" href="/2019/08/20/Rust中的变量寿命——lifetime/">Rust中的变量生存期——lifetime</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/13</span><a class="archive-post-title" href="/2019/08/13/Rust中的所有权规则-Ownership/">Rust中的所有权规则(Ownership)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/06</span><a class="archive-post-title" href="/2019/08/06/在vue组件中实现属性透传/">在vue组件中实现属性透传</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/05</span><a class="archive-post-title" href="/2019/05/05/Golang中的单例模式/">Golang中的单例模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/04</span><a class="archive-post-title" href="/2019/05/04/用Golang做一个命令行翻译工具/">用Golang做一个命令行翻译工具</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/01</span><a class="archive-post-title" href="/2019/05/01/Golang学习笔记——定义函数类型实现接口/">Golang学习笔记——定义函数类型实现接口</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/27</span><a class="archive-post-title" href="/2019/04/27/理解Angular中的Resolver/">理解Angular中的Resolver</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/07</span><a class="archive-post-title" href="/2019/03/07/无限动态列表/">无限动态列表</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/06</span><a class="archive-post-title" href="/2019/03/06/动态浮动按钮/">动态浮动按钮</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/24</span><a class="archive-post-title" href="/2019/02/24/在Flutter-Firebase应用中使用Redux——体重跟踪4/">在Flutter Firebase应用中使用Redux——体重跟踪4</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/09</span><a class="archive-post-title" href="/2019/02/09/Flutter中的Firebase数据库——体重跟踪APP-3/">Flutter中的Firebase数据库——体重跟踪APP 3</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/09</span><a class="archive-post-title" href="/2019/02/09/Scrapy学习笔记——Scrapy概览/">Scrapy学习笔记——Scrapy概览</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/20</span><a class="archive-post-title" href="/2019/01/20/用Flutter创建一个全屏的对话框-体重跟踪APP-2/">用Flutter创建一个全屏的对话框 - 体重跟踪APP 2</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/17</span><a class="archive-post-title" href="/2019/01/17/Flutter-ListView-教程-–-做一个体重追踪APP-1/">Flutter ListView 教程 – 做一个体重追踪APP 1</a>
        </li>
    
    </ul></div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="flutter"><span class="iconfont-archer">&#xe606;</span>flutter</span>
    
        <span class="sidebar-tag-name" data-tags="dart"><span class="iconfont-archer">&#xe606;</span>dart</span>
    
        <span class="sidebar-tag-name" data-tags="golang"><span class="iconfont-archer">&#xe606;</span>golang</span>
    
        <span class="sidebar-tag-name" data-tags="compile"><span class="iconfont-archer">&#xe606;</span>compile</span>
    
        <span class="sidebar-tag-name" data-tags="nginx"><span class="iconfont-archer">&#xe606;</span>nginx</span>
    
        <span class="sidebar-tag-name" data-tags="rust"><span class="iconfont-archer">&#xe606;</span>rust</span>
    
        <span class="sidebar-tag-name" data-tags="serde"><span class="iconfont-archer">&#xe606;</span>serde</span>
    
        <span class="sidebar-tag-name" data-tags="lifetime"><span class="iconfont-archer">&#xe606;</span>lifetime</span>
    
        <span class="sidebar-tag-name" data-tags="ownership"><span class="iconfont-archer">&#xe606;</span>ownership</span>
    
        <span class="sidebar-tag-name" data-tags="python"><span class="iconfont-archer">&#xe606;</span>python</span>
    
        <span class="sidebar-tag-name" data-tags="scrapy"><span class="iconfont-archer">&#xe606;</span>scrapy</span>
    
        <span class="sidebar-tag-name" data-tags="Mac"><span class="iconfont-archer">&#xe606;</span>Mac</span>
    
        <span class="sidebar-tag-name" data-tags="Sangfor"><span class="iconfont-archer">&#xe606;</span>Sangfor</span>
    
        <span class="sidebar-tag-name" data-tags="EasyConnect"><span class="iconfont-archer">&#xe606;</span>EasyConnect</span>
    
        <span class="sidebar-tag-name" data-tags="mysql"><span class="iconfont-archer">&#xe606;</span>mysql</span>
    
        <span class="sidebar-tag-name" data-tags="dble"><span class="iconfont-archer">&#xe606;</span>dble</span>
    
        <span class="sidebar-tag-name" data-tags="mycat"><span class="iconfont-archer">&#xe606;</span>mycat</span>
    
        <span class="sidebar-tag-name" data-tags="vue"><span class="iconfont-archer">&#xe606;</span>vue</span>
    
        <span class="sidebar-tag-name" data-tags="javascript"><span class="iconfont-archer">&#xe606;</span>javascript</span>
    
        <span class="sidebar-tag-name" data-tags="angular"><span class="iconfont-archer">&#xe606;</span>angular</span>
    
        <span class="sidebar-tag-name" data-tags="typescript"><span class="iconfont-archer">&#xe606;</span>typescript</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br>
    1、请确保node版本大于6.2<br>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="Flutter"><span class="iconfont-archer">&#xe60a;</span>Flutter</span>
    
        <span class="sidebar-category-name" data-categories="Go"><span class="iconfont-archer">&#xe60a;</span>Go</span>
    
        <span class="sidebar-category-name" data-categories="Nginx"><span class="iconfont-archer">&#xe60a;</span>Nginx</span>
    
        <span class="sidebar-category-name" data-categories="Rust"><span class="iconfont-archer">&#xe60a;</span>Rust</span>
    
        <span class="sidebar-category-name" data-categories="Scrapy"><span class="iconfont-archer">&#xe60a;</span>Scrapy</span>
    
        <span class="sidebar-category-name" data-categories="Blog"><span class="iconfont-archer">&#xe60a;</span>Blog</span>
    
        <span class="sidebar-category-name" data-categories="Database"><span class="iconfont-archer">&#xe60a;</span>Database</span>
    
        <span class="sidebar-category-name" data-categories="Vue"><span class="iconfont-archer">&#xe60a;</span>Vue</span>
    
        <span class="sidebar-category-name" data-categories="Angular"><span class="iconfont-archer">&#xe60a;</span>Angular</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "Richard Wong"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


